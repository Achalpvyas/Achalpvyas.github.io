<html>
  <head>
    <body background="img/page_background.png">
    <style>
        body {
            max-width 600px;
            margin: auto;
            margin-left: 20px;
            line-height: 20px;
            padding: 25px;
            width: 100%
            height: 100%
        }
        img {
            padding: 25px;
            display: block;
            margin: 0 auto;
            max-width: 600px;
            max-height: 100%
        }
    </style>
  </head>
  <body>
    
      <h1>Decision Making for Robotics</h1>
      <h2>Mini Project 1:</h2>
      <h2>Blossom Algorithm</h2>
      <h3>Authors: Achal Vyas and Pruthvi Sanghavi</h3>
      <hr> </hr>
<!--       <center><img src="img/blossom-intro.jpg" alt="Source: google images"></center> -->
    
      <h3>Summary</h3>
      <p>Blossom Algorithm is a matchmaking algorithm used to produce a maximum matching on any graph. It was created by Jack Edmunds in 1961.
          It has applications in a wide variety of fields of Robotics, Operations Theory, Biology, Mathematics etc. In this article, we will focus our attention on the applications in the domain of Robotics and Decision Making for Robotics.
          A matching is a graph that occurs when all vertices are connected to at most one other vertex through a single edge.
          A maximum matching occurs when the number of edges in the matching graph is maximized. 
      <br>Before we dive deeper into the intrinsics of the algorithm. First we will discuss, what is graph theory and its basic elements -</br>
      <br><br><b>Graph theory:</b> is the field of mathematics that deals with mathematical structures used to model pairwise relationships between objects.</br> 
      <br><b>Graph:</b>A Graph G is an ordered pair of disjoint sets G = (V, E) where E => VxV. Set V is called the vertex or the node set and Set E is called the edge set of graph G.</br>
      <br><b>Vertex:</b>A fundamental unit with which a graph is constructed.</br>
      <br><b>Edges:</b>The objects which connect the vertices to form a graph.</br>
      <br><b>Path:</b>A path is a sequence of vertices traversed using edges.</br>
      <br>A Graph is represented by a set of vertices and the edges connecting these vertices. The true essence of the graph theory is its flexibility with 
         which it can be used to model a wide variety of problems. A Graph is used in the domain of computer science to model communication networks, data strucures, computer organizations and flow of computations
         in the field of sociology to measure actors' prestige or to explore rumor spreading and in the field of <b>Robotics</b> to model multi robotics problem and task allocation problems. The Travelling Salesman Problem is an optimization problem and it can be used using the techniques applied to solve the problems
         in graphs. In multi robot applications, robots and the task space are modelled as a graph and a matching algorithm is used to allot the specific task to the robot.
      </p>
      
      <h3>Visualizing the Algorithm</h3>
      <p>The visualization of the algorithm is produced using TU Munich' Edmond's Blossom Algorithm Visualizer [7]</p>
      <center><img src="img/blossom.gif" alt="source: TUM Blossom Algorithm"></center>
      <p>Consider an undirected graph G as shown in the graphic.</p>
      <ol>
        <li>Unmatched vertices exists</li>
        <li>Start Breadth First Search</li>
        <li>Continuing BFS with the next nodes</li>
        <li>Checking the neighbours</li>
        <li>Reconstruction of the Augmenting Path</li>
        <li>Improved matching obtained</li>
        <li>Free vertices left</li>
        <li>Start Breadth-First Search Again</li>
        <li>Continue BFS with the next node</li>
        <li>Checking the next node</li>
        <li>Growing the BFS Trees</li>
        <li>Checking the next neighbours</li>
        <li>Contracting the Blossom</li>
        <li>Continue BFS with the next node</li>
        <li>Check the next neighbours</li>
        <li>Reconstruction of the Augmenting Path</li>
        <li>Reconstrucion of the Augmenting Path finished</li>
        <li>Improved Matching obtained</li>
      </ol>
      
    
      <h3>Formal definition using appropriate notation</h3>
      <p>Consider an undirected unweighted graph <b>G(V, E)</b>, where <b>V</b> and <b>E</b> are the set of vertices and the set of edges respectively. Let <b>M</b> denote the numbers of matchings in the graph <b>G</b></p>
      <center><img src="img/algorithm.png" alt="from references"></center>
      <p>Given a graph G and a matching M, M is a maximum matching if and only if there exists no M-augmenting path.</p>
      
      <h3>Overview of the key results</h3>
      
      <h3>Discussion of how the topic relates to decision-making for robotics</h3>
      <p>One of the important research areas in Robotics where the Blossom Algorithm has been applied extensively is the task allocation problem.</p>
        
      <p>Ghassemi, Payam, and Chowdhury, Souma in [1] shows the application of Blossom Algorithm in the task allocation problem. In multi robot task allocation application,
      the task planning problem can be fomulated as the maximum weighted matching of a bipartite graph. This problem can be solved using the Blossom' algorithm. This helps the multi agent system to autonomously identify 
      the sequence of tasks it should undertake. The bipartite graph is used to represnt and analyse the task-robot relationship. Once the weighted bipartite graph has been constructed, the
      final step (Fig. 1) is to solve the task assignment or allocation
      problem as a matching problem. This problem is defined as
      drawing a set of edges such that they do not share any vertices [29]. A weighted maximum matching method is used here
      to determine the optimal task assignment. Note that, until this
      point, all robots have taken the same (redundant) computational
      steps; however, this final step differs across robots, since each
      robot operates only on the portion of the bipartite graph relevant
      to itself (e.g., not consider tasks for which its bigraph connecting edge has a weight of zero). To perform this final step, an
      improved maximum matching algorithm proposed by Galil [30]
      is adopted. This algorithm is based on the classical blossom algorithm introduced by Edmonds [31], which is known to run in
      polynomial time. The pseudocode of this algorithm is given in
      Algorithm 1. This algorithm produces the optimal decision function, M (i.e. the task assignment set). It is important to note
      that the outcomes of this decentralized decision-making process
      is deterministic and synchronized (assuming a deterministic environment with perfect localization). Consequently, each robot
      will arrive at the same conflict-free optimal task assignment outcomes. Although, currently, a degree of redundancy of taking the
      same decision on-board each robot (w.r.t. the same task cluster)
      is allowed, more efficient implementations can be explored in
      the future. These future advancements could also help promote
      asynchronous multi-agent decision-making, which is a highlychallenging and an open area of research in itself [32]</p>
      

      <center><img src="img/example.png" alt="source: from research paper"></center>
      <center><img src="img/graph.png" alt="from research paper DEC Mata"></center>
      
      <h3>Brief description of variants (as appropriate)</h3>
      
      <h3>Overview of the important applications</h3>
      
      <h3>Discussion of open research questions</h3>
      
      
      <center><img src="img/graph-joke.png" alt="Source: xkcd comic"></center>
      
      <h3>References</h3>
      <ol>
        <li>Ghassemi, Payam, and Chowdhury, Souma. "Decentralized Task Allocation in Multi-Robot Systems via Bipartite Graph Matching Augmented With Fuzzy Clustering." Proceedings of the ASME 2018 International Design Engineering Technical Conferences and Computers and Information in Engineering Conference. Volume 2A: 44th Design Automation Conference. Quebec City, Quebec, Canada. August 26â€“29, 2018. V02AT03A014. ASME. https://doi.org/10.1115/DETC2018-86161</li>
        <li>Edmonds, J. (1965). Paths, Trees, and Flowers. Canadian Journal of Mathematics, 17, 449-467. doi:10.4153/CJM-1965-045-4</li>
        <li>Blum, N. (2015). Maximum Matching in General Graphs Without Explicit Consideration of Blossoms Revisited. ArXiv, abs/1509.04927.</li>
        <li>Harold N. Gabow:Data Structures for Weighted Matching and Extensions to b-matching and f-factors. ACM Trans. Algorithms 14(3): 39:1-39:80 (2018)</li>
        <li><a href="http://www.fang.ece.ufl.edu/eel6935/presentation/GraphTheory.pdf">http://www.fang.ece.ufl.edu/eel6935/presentation/GraphTheory.pdf</a></li>
        <li><a href="https://courses.lumenlearning.com/waymakermath4libarts/chapter/graph-theory/">Elements of Graph Theory</a></li>
        <li><a href="https://www-m9.ma.tum.de/graph-algorithms/matchings-blossom-algorithm/index_en.html">https://www-m9.ma.tum.de/graph-algorithms/matchings-blossom-algorithm/index_en.html</a></li>
        <li><a href="https://www.eecs.tufts.edu/~gdicks02/Blossom/Blossom_Algorithm.html">https://www.eecs.tufts.edu/~gdicks02/Blossom/Blossom_Algorithm.html</a></li>
        <li><a href="http://www.cs.cmu.edu/~anupamg/advalgos15/lectures/lecture08.pdf">http://www.cs.cmu.edu/~anupamg/advalgos15/lectures/lecture08.pdf</a></li>
        <li><a href="https://en.wikipedia.org/wiki/Graph_theory#Applications">https://en.wikipedia.org/wiki/Graph_theory#Applications</a></li>
        <li><a href="https://en.wikipedia.org/wiki/Bipartite_graph">https://en.wikipedia.org/wiki/Bipartite_graph</a></li>
        <li><a href="https://people.scs.carleton.ca/~maheshwa/courses/5703COMP/16Fall/Matching-Report.pdf">https://people.scs.carleton.ca/~maheshwa/courses/5703COMP/16Fall/Matching-Report.pdf</a></li>
        <li><a href="http://web.eecs.utk.edu/~jplank/plank/classes/cs494/494/notes/Edmonds/index.html">http://web.eecs.utk.edu/~jplank/plank/classes/cs494/494/notes/Edmonds/index.html</a></li>
      </ol>
    
  </body>
</html>
